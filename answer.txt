
//题目描述:
//把二叉树打印成多行
//从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
//https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot)
        {
            vector<vector<int> > result;
            if(NULL == pRoot)
                return result;
            queue<TreeNode*> q1, q2;
            q1.push(pRoot);
            while(!q1.empty())
            {
                vector<int> tmp;
                while(!q1.empty())//用q2来存放下一层的值的地址
                {
                    tmp.push_back(q1.front()->val);//tmp用来暂时存放某一层的值(相当于取出q1对应的值)
                    if(NULL != q1.front()->left)
                        q2.push(q1.front()->left);
                    if(NULL != q1.front()->right)
                        q2.push(q1.front()->right);
                    q1.pop();
                }
                while(!q2.empty())//将q2里面的内容放到q1中
                {
                    q1.push(q2.front());
                    q2.pop();
                }
                result.push_back(tmp);
            }

            return result;
        }
    
};

//题目描述
//重建二叉树
//输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和
//中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍
//历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin)
    {
        if(pre.empty() || vin.empty())
            return NULL;
        TreeNode* root = new TreeNode(pre[0]);//生成二叉树的根节点
        int i = 0, root_loc = 0;
        while(vin[i] != pre[0])
        {
            ++i;
        }
        root_loc = i;//用root_loc记录根节点的下标
        vector<int> pre_left, pre_right, vin_left, vin_right;
        //将下一次递归调用时左子树的pre和vin数组准备好
        for(i = 0; i < root_loc; ++i)
        {
            pre_left.push_back(pre[i+1]);
            vin_left.push_back(vin[i]);
        }
        //将下一次递归调用时右子树的pre和vin数组准备好
        for(i = root_loc + 1; i < vin.size(); ++i)
        {
            pre_right.push_back(pre[i]);
            vin_right.push_back(vin[i]);
        }
        //递归调用，生成二叉树的左右子树
        root->left = reConstructBinaryTree(pre_left, vin_left);
        root->right = reConstructBinaryTree(pre_right, vin_right);
        return root;
    }
};


//题目描述
//用两个栈实现队列
//用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
//https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
class Solution
{
public:
    void push(int node)
    {
        stack1.push(node);
    }

    int pop()
    {
        if(stack2.empty())
        {
            while(!stack1.empty())
            {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int num = stack2.top();
        stack2.pop();
        return num;
    }

private:
    stack<int> stack1;//用来入栈
    stack<int> stack2;//用来出栈
};